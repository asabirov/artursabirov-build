<!DOCTYPE html>
<html dir='ltr' lang='ru-RU'>
  <head>
    <meta charset='utf-8'>
    <title>Cramp и Rails</title>
    <link href='http://feeds.feedburner.com/artursabirov' rel='alternate' title='ArturSabirov.ru' type='application/rss+xml'>
    <link href="/stylesheets/blog.css" media="screen" rel="stylesheet" type="text/css" />
    <meta content='width=device-width, initial-scale=1.0' name='viewport'>
    <script charset='windows-1251' src='http://vkontakte.ru/js/api/openapi.js?29' type='text/javascript'></script>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="http://feeds.feedburner.com/artursabirov//dev" />
    <script>
      VK.init({apiId: 2348265, onlyWidgets: true});
    </script>
    <script>
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-24946626-1']);
      _gaq.push(['_trackPageview']);
      
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <header>
      <section>
        <h1 id='page_heading'>
          <a href='/'>Блог Артура Сабирова</a>
        </h1>
        <nav>
          <a href="/dev">Разработка</a>
          <a href="/projects">Проекты</a>
          <a href="/books">Книги</a>
          <a href="/life">Жизнь</a>
          <a href="/about">О себе</a>
        </nav>
      </section>
    </header>
    <section id='single-column'>
      <article>
        <h1>Cramp и Rails</h1>
        <p>Если вам нужна асинхронность, то лучше сразу задуматься, нужен ли rails вовсе. На Cramp или Node.js можно без проблем совместить comet-транспорт с обычными http-request'ами. Cramp хорошо сочитается с Sinatra, который недавно обзавелся своей версией <a href="https://github.com/stevehodgkiss/sinatra-asset-pipeline.">Assets Pipeline</a></p>&#x000A;&#x000A;<h2 id="cramp">Cramp</h2>&#x000A;&#x000A;<p><a href="http://cramp.in/.">Cramp</a>&#x000A;Легкий фреймворк, использует EventMachine и файберсы. Умеет  работать с http, веб-сокетами, flash-сокетами и long-polling-запросами для старых браузеров.</p>&#x000A;&#x000A;<p>Пример приложения на Cramp взят отсюда — http://www.html5rocks.com/en/tutorials/casestudies/sunlight_streamcongress.html.</p>&#x000A;&#x000A;<p>app.ru</p>&#x000A;&#x000A;<pre class="highlight plaintext">require "rubygems"&#x000A;require "bundler"&#x000A;Bundler.require&#x000A;require 'cramp'&#x000A;require 'http_router'&#x000A;require 'active_support/json'&#x000A;require 'thin'&#x000A;&#x000A;Cramp::Websocket.backend = :thin # используем асинхронный сервер thin&#x000A;&#x000A;class LiveSocket &lt; Cramp::Websocket&#x000A;   periodic_timer :check_activities, :every =&gt; 15&#x000A;&#x000A;   def check_activities&#x000A;     @latest_activity ||= nil&#x000A;     new_activities = find_activities_since(@latest_activity)&#x000A;     @latest_activity = new_activities.first unless new_activities.empty?&#x000A;     render new_activities.to_json&#x000A;   end&#x000A; end&#x000A;&#x000A;routes = HttpRouter.new do&#x000A;  add('/live').to(LiveSocket)&#x000A;end&#x000A;run routes&#x000A;&#x000A;</pre>&#x000A;&#x000A;<p>Запуск приложения</p>&#x000A;&#x000A;<pre class="highlight plaintext">bundle exec thin --timeout 0 -R app.ru start&#x000A;&#x000A;</pre>&#x000A;&#x000A;<h2 id="goliath">Goliath</h2>&#x000A;&#x000A;<p>Сам я лично с ним не работал, но и упомянуть о нем не мог. Довольно известное решение в узких кругах. Посмотрите обязательно — <a href="https://github.com/postrank-labs/goliath.">https://github.com/postrank-labs/goliath</a></p>&#x000A;&#x000A;<h2 id="nodejs">Node.js</h2>&#x000A;&#x000A;<p>Это конечно не ruby-way, зато выбор ноды дает нам некоторое <a href="http://posterous.mclov.in/unscientific-nodejs-vs-cramp-benchmarks.">преимущество в производительности</a>&#x000A;Что будет немаловажным при нагрузках.</p>&#x000A;&#x000A;<p>Дополнительные npm модули для транспорта и маршрутизации:</p>&#x000A;&#x000A;<ul>&#x000A;  <li>&#x000A;    <p><a href="http://faye.jcoglan.com.">Faye</a></p>&#x000A;  </li>&#x000A;  <li><a href="https://github.com/maccman/juggernaut">Jaggernaut</a></li>&#x000A;  <li><a href="https://github.com/learnboost/socket.io">Socket.io</a></li>&#x000A;</ul>&#x000A;&#x000A;<p>Подойдет любой из них. Возможности у них примерно равны.</p>&#x000A;&#x000A;<p>Пример приложения с использованием Faye (app.js):</p>&#x000A;&#x000A;<pre class="highlight javascript"><span class="kd">var</span> <span class="nx">Faye</span>   <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'faye'</span><span class="p">),</span>&#x000A;    <span class="nx">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Faye</span><span class="p">.</span><span class="nx">NodeAdapter</span><span class="p">({</span><span class="na">mount</span><span class="p">:</span> <span class="s1">'/live'</span><span class="p">});</span>&#x000A;&#x000A;<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">9292</span><span class="p">);</span> <span class="c1">// создаем сервер&#x000A;</span>&#x000A;<span class="kd">var</span> <span class="nx">client</span> <span class="o">=</span> <span class="nx">server</span><span class="p">.</span><span class="nx">getClient</span><span class="p">()</span>&#x000A;&#x000A;<span class="c1">// прослушка канала messages&#x000A;</span><span class="nx">client</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">'/messages'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>&#x000A;  <span class="nx">alert</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">text</span><span class="p">);</span>&#x000A;<span class="p">});</span>&#x000A;&#x000A;<span class="c1">// публикация в канал messages&#x000A;</span><span class="nx">client</span><span class="p">.</span><span class="nx">publish</span><span class="p">(</span><span class="s1">'/messages'</span><span class="p">,</span> <span class="p">{</span>&#x000A;  <span class="na">text</span><span class="p">:</span> <span class="s1">'Hello world'</span>&#x000A;<span class="p">});</span>&#x000A;&#x000A;</pre>&#x000A;&#x000A;<p>Запуск:</p>&#x000A;&#x000A;<p>~~~forever app.js~~~</p>&#x000A;&#x000A;<h2 id="erlang">Erlang</h2>&#x000A;&#x000A;<p>Сложность языка накладывают свои ограничения по скорости разработки и квалификации, но это лучший выбор если вы ограничены в серверных ресурсах.</p>&#x000A;&#x000A;<p>Пример работы с веб-сокетами на фреймворке MochiWeb — <a href="https://github.com/RJ/mochiweb-websockets/tree/master/examples/websockets">https://github.com/RJ/mochiweb-websockets/tree/master/examples/websockets</a></p>&#x000A;&#x000A;<h2 id="section">Склейка</h2>&#x000A;&#x000A;<p>Ситуация теперь следующая. Сайт на 80м порту (пусть будет Nginx), real-time сервер на 9292. Чтобы избежать нарушения <a href="http://en.wikipedia.org/wiki/Same_origin_policy">same-origin-policy</a>&#x000A;нам потребуется объединить обе части сервера. </p>&#x000A;&#x000A;<p>Этой проблемы можно было избежать, написав всё на Node.JS или Cramp. О чем говорил в начале статьи.</p>&#x000A;&#x000A;<h2 id="haproxy">HAPRoxy</h2>&#x000A;&#x000A;<p>Сам Nginx не умеет маршрутизировать websocket'ы и http на одном хосте. В этом поможет HAProxy — очень простой и производительный proxy-сервер.</p>&#x000A;&#x000A;<pre class="highlight plaintext">wget http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.18.tar.gz&#x000A;tar zxvf http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.18.tar.gz&#x000A;mv haproxy-1.4.18 /usr/local/haproxy&#x000A;ln -s /usr/local/haproxy/haproxy /usr/sbin/haproxy&#x000A;&#x000A;</pre>&#x000A;&#x000A;<p>Скрипт автозапуска для CentOS:</p>&#x000A;&#x000A;<pre class="highlight shell"><span class="c"># description: HA-Proxy is a TCP/HTTP reverse proxy which is particularly suited \</span>&#x000A;<span class="c">#              for high availability environments.</span>&#x000A;<span class="c"># processname: haproxy</span>&#x000A;<span class="c"># chkconfig: 345 20 80</span>&#x000A;<span class="c"># config: /etc/haproxy.cfg</span>&#x000A;<span class="c"># pidfile: /var/run/haproxy.pid</span>&#x000A;&#x000A;<span class="c"># Source function library.</span>&#x000A;<span class="k">if</span> <span class="o">[</span> -f /etc/init.d/functions <span class="o">]</span>; <span class="k">then</span>&#x000A;  . /etc/init.d/functions&#x000A;<span class="k">elif</span> <span class="o">[</span> -f /etc/rc.d/init.d/functions <span class="o">]</span> ; <span class="k">then</span>&#x000A;  . /etc/rc.d/init.d/functions&#x000A;<span class="k">else&#x000A;  </span><span class="nb">exit </span>0&#x000A;<span class="k">fi</span>&#x000A;&#x000A;<span class="c"># Source networking configuration.</span>&#x000A;. /etc/sysconfig/network&#x000A;&#x000A;<span class="c"># Check that networking is up.</span>&#x000A;<span class="o">[</span> <span class="k">${</span><span class="nv">NETWORKING</span><span class="k">}</span> <span class="o">=</span> <span class="s2">"no"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">exit </span>0&#x000A;&#x000A;<span class="o">[</span> -f /etc/haproxy.cfg <span class="o">]</span> <span class="o">||</span> <span class="nb">exit </span>1&#x000A;&#x000A;<span class="nv">RETVAL</span><span class="o">=</span>0&#x000A;&#x000A;start<span class="o">()</span> <span class="o">{</span>&#x000A;  /usr/sbin/haproxy -c -q -f /etc/haproxy.cfg&#x000A;  <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -ne 0 <span class="o">]</span>; <span class="k">then&#x000A;    </span><span class="nb">echo</span> <span class="s2">"Errors found in configuration file."</span>&#x000A;    <span class="k">return </span>1&#x000A;  <span class="k">fi&#x000A;&#x000A;  </span><span class="nb">echo</span> -n <span class="s2">"Starting HAproxy: "</span>&#x000A;  daemon /usr/sbin/haproxy -D -f /etc/haproxy.cfg -p /var/run/haproxy.pid&#x000A;  <span class="nv">RETVAL</span><span class="o">=</span><span class="nv">$?</span>&#x000A;  <span class="nb">echo</span>&#x000A;  <span class="o">[</span> <span class="nv">$RETVAL</span> -eq 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> touch /var/lock/subsys/haproxy&#x000A;  <span class="k">return</span> <span class="nv">$RETVAL</span>&#x000A;<span class="o">}</span>&#x000A;&#x000A;stop<span class="o">()</span> <span class="o">{</span>&#x000A;  <span class="nb">echo</span> -n <span class="s2">"Shutting down HAproxy: "</span>&#x000A;  killproc haproxy -USR1&#x000A;  <span class="nv">RETVAL</span><span class="o">=</span><span class="nv">$?</span>&#x000A;  <span class="nb">echo</span>&#x000A;  <span class="o">[</span> <span class="nv">$RETVAL</span> -eq 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> rm -f /var/lock/subsys/haproxy&#x000A;  <span class="o">[</span> <span class="nv">$RETVAL</span> -eq 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> rm -f /var/run/haproxy.pid&#x000A;  <span class="k">return</span> <span class="nv">$RETVAL</span>&#x000A;<span class="o">}</span>&#x000A;&#x000A;restart<span class="o">()</span> <span class="o">{</span>&#x000A;  /usr/sbin/haproxy -c -q -f /etc/haproxy.cfg&#x000A;  <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -ne 0 <span class="o">]</span>; <span class="k">then&#x000A;    </span><span class="nb">echo</span> <span class="s2">"Errors found in configuration file, check it with 'haproxy check'."</span>&#x000A;    <span class="k">return </span>1&#x000A;  <span class="k">fi&#x000A;  </span>stop&#x000A;  start&#x000A;<span class="o">}</span>&#x000A;&#x000A;check<span class="o">()</span> <span class="o">{</span>&#x000A;  /usr/sbin/haproxy -c -q -V -f /etc/haproxy.cfg&#x000A;<span class="o">}</span>&#x000A;&#x000A;rhstatus<span class="o">()</span> <span class="o">{</span>&#x000A;  status haproxy&#x000A;<span class="o">}</span>&#x000A;&#x000A;condrestart<span class="o">()</span> <span class="o">{</span>&#x000A;  <span class="o">[</span> -e /var/lock/subsys/haproxy <span class="o">]</span> <span class="o">&amp;&amp;</span> restart <span class="o">||</span> :&#x000A;<span class="o">}</span>&#x000A;&#x000A;<span class="c"># See how we were called.</span>&#x000A;<span class="k">case</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="k">in&#x000A;  </span>start<span class="p">)</span>&#x000A;    start&#x000A;    <span class="p">;;</span>&#x000A;  stop<span class="p">)</span>&#x000A;    stop&#x000A;    <span class="p">;;</span>&#x000A;  restart<span class="p">)</span>&#x000A;    restart&#x000A;    <span class="p">;;</span>&#x000A;  reload<span class="p">)</span>&#x000A;    restart&#x000A;    <span class="p">;;</span>&#x000A;  condrestart<span class="p">)</span>&#x000A;    condrestart&#x000A;    <span class="p">;;</span>&#x000A;  status<span class="p">)</span>&#x000A;    rhstatus&#x000A;    <span class="p">;;</span>&#x000A;  check<span class="p">)</span>&#x000A;    check&#x000A;    <span class="p">;;</span>&#x000A;  <span class="k">*</span><span class="p">)</span>&#x000A;    <span class="nb">echo</span> <span class="s2">$"Usage: haproxy {start|stop|restart|reload|condrestart|status|check}"</span>&#x000A;    <span class="nv">RETVAL</span><span class="o">=</span>1&#x000A;<span class="k">esac&#x000A;&#x000A;</span><span class="nb">exit</span> <span class="nv">$RETVAL</span>&#x000A;&#x000A;</pre>&#x000A;&#x000A;<pre class="highlight plaintext">chkconfig haproxy on&#x000A;&#x000A;</pre>&#x000A;&#x000A;<p>Настроим конфигурацию для адреса 85.17.162.170. Nginx будет 8081 порту, Node.JS на 9292. Вместо Node.JS может быть любой бэкэнд, конфиг от этого не сильно изменится.</p>&#x000A;&#x000A;<p>/etc/haproxy.conf</p>&#x000A;&#x000A;<pre class="highlight plaintext">global&#x000A;    maxconn	4096&#x000A;    spread-checks 5&#x000A;    pidfile	/var/run/haproxy.pid&#x000A;    &#x000A;    user	haproxy&#x000A;    group	haproxy&#x000A;    &#x000A;defaults&#x000A;    mode http&#x000A;    option forwardfor&#x000A;    option abortonclose&#x000A;    option httpclose&#x000A;    no option accept-invalid-http-request&#x000A;    no option accept-invalid-http-response&#x000A;    option forwardfor except 127.0.0.1 header X-Forwarded-For&#x000A;&#x000A;frontend all 85.17.162.170:80&#x000A;    timeout client 1d&#x000A;    &#x000A;    acl is_nodejs url_sub faye # если мы используется Faye&#x000A;    acl is_nodejs hdr(upgrade) -i websocket # определяем веб-сокеты по заголовкам&#x000A;    acl is_nodejs hdr_beg(Host) -i ws # определяем веб-сокеты по ws://&#x000A;    use_backend nodejs_backend if is_nodejs # нужные отправляем на Node.JS&#x000A;    default_backend   nginx_backend    # остальные на nginx&#x000A;    &#x000A;backend nodejs_backend&#x000A;    server server1 85.17.162.170:9292 maxconn 200 check&#x000A;    balance roundrobin    &#x000A;    timeout queue 5s&#x000A;    timeout server  86400000&#x000A; &#x000A;backend nginx_backend&#x000A;    balance roundrobin&#x000A;    option forwardfor&#x000A;    timeout connect 100s    &#x000A;    timeout server 25s&#x000A;    server server1 85.17.162.170:8081 check&#x000A;&#x000A;</pre>&#x000A;&#x000A;<p>Необходимо убедиться, что Nginx больше не прослушивает 80й порт и в конфигах стоит "listen 85.17.162.92:8081".</p>&#x000A;&#x000A;<p>Запуск.</p>&#x000A;&#x000A;<pre class="highlight plaintext">service haproxy start&#x000A;&#x000A;</pre>&#x000A;&#x000A;<h2 id="frontend">Frontend</h2>&#x000A;&#x000A;<p>Рассмотрим на примере с Faye. </p>&#x000A;&#x000A;<p>Подключаем faye.js. </p>&#x000A;&#x000A;<pre class="highlight html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"http://domain.com/faye.js"</span><span class="nt">&gt;&lt;/script&gt;</span>&#x000A;</pre>&#x000A;&#x000A;<p>Этот файл генерируется самим faye.</p>&#x000A;&#x000A;<p>Подключаемся к каналу /messages:</p>&#x000A;&#x000A;<pre class="highlight html">var client = new Faye.Client('http://domain.com/live');&#x000A;var subscription = client.subscribe('/messages', function(message) {&#x000A;    console.log(message)&#x000A;});&#x000A;&#x000A;</pre>&#x000A;&#x000A;<h2 id="frontend-1">Frontend</h2>&#x000A;&#x000A;<p>Рассмотрим на примере с Faye. </p>&#x000A;&#x000A;<p>Подключаем faye.js. </p>&#x000A;&#x000A;<pre class="highlight html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"http://domain.com/faye.js"</span><span class="nt">&gt;&lt;/script&gt;</span>&#x000A;</pre>&#x000A;&#x000A;<p>Этот файл генерируется самим faye.</p>&#x000A;&#x000A;<p>Подключаемся к каналу /messages:</p>&#x000A;&#x000A;<pre class="highlight html">var client = new Faye.Client('http://domain.com/live');&#x000A;var subscription = client.subscribe('/messages', function(message) {&#x000A;    console.log(message)&#x000A;});&#x000A;&#x000A;</pre>&#x000A;&#x000A;<h2 id="section-1">Резюме</h2>&#x000A;&#x000A;<p>Real-time приложения требуют особого подхода и далеко не все классические инструменты подходят для этих целей. Ruby хоть умеет создавать треды, обладает реализацией eventmachine и даже облегчает код файберсами, но сильно проигрывает в производительности асинхронным технологиям. В Node.JS и Erlang изначально были продуманы проблемы многозадачности и эффективного использования ресурсов. В real-time приложениях это может быть критически важным фактором.</p>
        <h4 class='meta'>
          <div class='tags'>
            <a href="/dev/tags/rails/">rails</a>
            <a href="/dev/tags/ruby/">ruby</a>
            <a href="/dev/tags/node-js/">node.js</a>
            <a href="/dev/tags/erlang/">erlang</a>
          </div>
        </h4>
      </article>
    </section>
    <script src="/javascripts/application.js" type="text/javascript"></script>
  </body>
</html>

